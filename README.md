Code challenges and data structures and algorithms for Codefellows 401 Java course.

# Table of contents
- [Basics: arrays, loops, binary search](docs/basics.md)
- [Linked lists](docs/linked-list.md)
- [Using stacks and queues](docs/stacks-queues.md)
- [Binary and rose trees](docs/binary-trees.md)
- [Sorting](docs/sorting.md)
- [Hash-based data structures](docs/hash-tables.md)
- [Graphs: implementations and uses](docs/graphs.md)

# Day by day summaries

## Day 1: Reverse an Array

The challenge asked us to reverse an array. It gave us the option to either reverse the array in place or create a new
reversed array. We came up with solutions to both.

[Summary](docs/array-reverse.md) for the first code challenge.

## Day 2: Arrays, loops, and unit testing

Code challenge two asks us to insert an element into the middle of an array. [Summary](docs/array-shift.md) of our
second code challenge.

## Day 3: Binary search

The third code challenge asks us to implement the classic binary search algorithm on a sorted list of `int`
s. [Details](docs/binary-search.md) on the third code challenge.

## Day 5: Linked List

We implement a basic linked list class with just a few instance methods. This class will get fleshed out more
later. [Details](docs/linked-list.md) on the linked list class.

## Day 6: Insertion and Deletion in LinkedLists

We build on the linked list class from day 5 and add insertion and deletion to the API.

## Day 7: Indexing from beginning and end in LinkedList

We continue building on the linked list class and implement a way to access elements by index.

## Day 10: Stacks and Queues implementations

We defined the interface for a stack and a queue and implement both classes using linked lists. Details on the [stacks and queues labs](docs/stacks-queues.md).

## Day 11: Implementing a Queue with Two Stacks

Our challenge was to implement a Queue using two Stacks.

## Day 12: Implementing a Specialized Queue

Our challenge is to implement a queue that accepts elements of different types, allowing us to dequeue the item of a specific type that's been in the queue the longest, and allowing us to dequeue the item of any time that's been in the queue for the longest.

## Day 14: Matching brackets with a stack

We use a stack to implement a solution to the matching brackets problem, where we validate whether or not the brackets in a string are matching and balanced.

## Day 15: Implementing a binary tree and binary search tree

In this [series](docs/binary-trees.md) of challenges we're asked to implement various implementations of and algorithms on binary trees. We define a class of binary trees and implement several methods to traverse over the binary tree. Then we extend this class to create a binary search tree, adding insertion and search methods.

## Day 16: Finding the maximum of a binary tree

In this challenge we're asked to write a method on a binary tree that finds the maximum value in that tree.

## Day 17: Implementing the breadth first search

In this challenge we're asked to implement a breadth first search on a binary tree.

## Day 18: Rose trees (k-ary trees) and fizz buzz

In this challenge we implement a k-ary tree and then create a new tree based on that original tree according to the "fizz buzz" rules.

## Day 26: Insertion sort

In this next week of challenges we are investigating various sorting algorithms. Today's [challenge](docs/sorting.md#day-26-insertion-sort) is the basic insertion sort algorithm.

## Day 27: Merge sort

Today's [challenge](docs/sorting.md#day-27-merge-sort) implements the merge sort algorithm.

## Day 28: Quick sort

Today's [challenge](docs/sorting.md#day-28-quick-sort) implements the quick sort algorithm.

## Day 30: Hash Tables

We define a Map interface and implement a HashTable with separate chaining (linked list) in this [challenge](docs/hash-tables.md)

## Day 31: Counting word frequency

We define a class that determines word frequency on a String in this [challenge](docs/hash-tables.md#day-31-counting-word-frequency).

## Day 35: Graph implementations

We implement a variety of [graph](docs/graphs.md) data structures and investigate their properties.

## Day 36: Graph traversals

We implement a number of ways to traverse a graph in this [challenge](docs/graphs.md#Day-36-traversals).

## Day 37: Paths and shortest paths

We implement a method that takes a sequence of nodes and determines whether the nodes form a path in the given graph. We also implement Dijkstra's algorithm for finding the shortest path in this [challenge](docs/graphs.md#Day-37-paths) data structures and investigate their properties.
